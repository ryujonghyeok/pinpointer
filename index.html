<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Precision Finding</title>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- React & ReactDOM -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  
  <!-- Babel for in-browser JSX compilation -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    /* iOS Browser Cut-off Fix: 
      Use Dynamic Viewport Height (dvh) to strictly fit between the browser's top and bottom toolbars.
      Locking overflow prevents the whole page from bouncing/scrolling.
    */
    html, body, #root {
      height: 100vh; /* Fallback for older browsers */
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
      overscroll-behavior-y: none;
      -webkit-user-select: none;
      user-select: none;
    }

    @supports (height: 100dvh) {
      html, body, #root {
        height: 100dvh;
      }
    }
  </style>
</head>
<body class="bg-black text-white">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useCallback } = React;

    // --- Inline Icons ---
    const Icon = ({ children, className = "", size = 24 }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        {children}
      </svg>
    );
    const SearchIcon = (props) => <Icon {...props}><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></Icon>;
    const CrosshairIcon = (props) => <Icon {...props}><circle cx="12" cy="12" r="10"/><line x1="22" x2="18" y1="12" y2="12"/><line x1="6" x2="2" y1="12" y2="12"/><line x1="12" x2="12" y1="6" y2="2"/><line x1="12" x2="12" y1="22" y2="18"/></Icon>;
    const MapPinIcon = (props) => <Icon {...props}><path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z"/><circle cx="12" cy="10" r="3"/></Icon>;
    const CompassIcon = (props) => <Icon {...props}><circle cx="12" cy="12" r="10"/><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"/></Icon>;
    const XIcon = (props) => <Icon {...props}><path d="M18 6 6 18"/><path d="m6 6 12 12"/></Icon>;

    // --- Math & Geo Utilities ---
    const toRad = (value) => (value * Math.PI) / 180;
    const toDeg = (value) => (value * 180) / Math.PI;

    const calculateDistance = (lat1, lon1, lat2, lon2) => {
      const R = 6371e3;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c; // Distance in meters
    };

    const calculateBearing = (lat1, lon1, lat2, lon2) => {
      const dLon = toRad(lon2 - lon1);
      const y = Math.sin(dLon) * Math.cos(toRad(lat2));
      const x =
        Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) -
        Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLon);
      const bearing = Math.atan2(y, x);
      return (toDeg(bearing) + 360) % 360;
    };

    // --- Main App Component ---
    function App() {
      const [appState, setAppState] = useState('SEARCH');
      const [searchQuery, setSearchQuery] = useState('');
      const [searchResults, setSearchResults] = useState([]);
      const [isSearching, setIsSearching] = useState(false);
      const [target, setTarget] = useState(null);

      const [currentLoc, setCurrentLoc] = useState(null);
      const [heading, setHeading] = useState(0);
      const [geoError, setGeoError] = useState(null);
      
      const [distance, setDistance] = useState(0);
      const [bearing, setBearing] = useState(0);

      // Native Browser Back Button Support
      useEffect(() => {
        const handlePopState = () => {
          if (window.location.hash !== '#tracking') {
            setAppState('SEARCH');
            setTarget(null);
            setCurrentLoc(null);
          }
        };
        window.addEventListener('popstate', handlePopState);
        return () => window.removeEventListener('popstate', handlePopState);
      }, []);

      const handleSearch = async (e) => {
        e.preventDefault();
        if (!searchQuery.trim()) return;

        // Auto-detect Coordinates (e.g., 37.51551, 126.88110)
        const coordMatch = searchQuery.trim().match(/^(-?\d+(\.\d+)?)[,\s]+(-?\d+(\.\d+)?)$/);
        if (coordMatch) {
          const lat = parseFloat(coordMatch[1]);
          const lon = parseFloat(coordMatch[3]);
          selectTarget({ lat, lon, display_name: "Pinned Coordinates" });
          return;
        }
        
        setIsSearching(true);

        const performSearch = async (userLat, userLon) => {
          try {
            // Fetch more results to allow accurate local sorting
            const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchQuery)}&limit=15`);
            const data = await res.json();

            // Order by distance if we successfully got user's location
            if (userLat !== null && userLon !== null) {
              data.forEach(item => {
                item.distFromUser = calculateDistance(userLat, userLon, parseFloat(item.lat), parseFloat(item.lon));
              });
              data.sort((a, b) => a.distFromUser - b.distFromUser);
            }

            setSearchResults(data);
          } catch (err) {
            console.error("Search failed:", err.message || err);
            alert("Failed to search location. Please check your connection.");
          } finally {
            setIsSearching(false);
          }
        };

        // Try to briefly grab the current location so we can sort results by distance
        if ('geolocation' in navigator) {
          navigator.geolocation.getCurrentPosition(
            (pos) => performSearch(pos.coords.latitude, pos.coords.longitude),
            (err) => performSearch(null, null), // Fallback to unsorted if denied/fails
            { timeout: 2500, maximumAge: 60000, enableHighAccuracy: false }
          );
        } else {
          performSearch(null, null);
        }
      };

      const selectTarget = (item) => {
        const newTarget = {
          lat: parseFloat(item.lat),
          lon: parseFloat(item.lon),
          name: item.display_name.split(',')[0]
        };
        setTarget(newTarget);
        setAppState('TRACKING');
        window.history.pushState(null, '', '#tracking');
        startSensors(newTarget);
      };

      const handleOrientation = useCallback((event) => {
        let compassHeading = null;
        if (event.webkitCompassHeading) {
          compassHeading = event.webkitCompassHeading;
        } else if (event.alpha !== null) {
          compassHeading = 360 - event.alpha;
        }
        
        if (compassHeading !== null) {
          setHeading(compassHeading);
        }
      }, []);

      const startSensors = async (currentTarget) => {
        setGeoError(null);

        if ('geolocation' in navigator) {
          navigator.geolocation.watchPosition(
            (position) => {
              setCurrentLoc({
                lat: position.coords.latitude,
                lon: position.coords.longitude,
                accuracy: position.coords.accuracy
              });
            },
            (error) => {
              console.error("Geolocation error:", error.message || error);
              setGeoError("GPS blocked/unavailable. Using simulated location.");
              if (currentTarget) {
                setCurrentLoc({
                  lat: currentTarget.lat - 0.0003,
                  lon: currentTarget.lon - 0.0003,
                  accuracy: 5
                });
              }
            },
            { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
          );
        } else {
          setGeoError("Geolocation is not supported by your browser.");
        }

        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
          try {
            const permission = await DeviceOrientationEvent.requestPermission();
            if (permission === 'granted') {
              window.addEventListener('deviceorientation', handleOrientation, true);
            } else {
              setGeoError("Compass permission denied. Tap here to try again.");
            }
          } catch (err) {
            console.error("Orientation permission error:", err.message || err);
          }
        } else {
          window.addEventListener('deviceorientationabsolute', handleOrientation, true);
        }
      };

      const stopTracking = () => {
        if (window.location.hash === '#tracking') {
          window.history.back(); // Use native back function
        } else {
          setAppState('SEARCH');
          setTarget(null);
          setCurrentLoc(null);
        }
      };

      useEffect(() => {
        if (currentLoc && target) {
          const distMeters = calculateDistance(currentLoc.lat, currentLoc.lon, target.lat, target.lon);
          const bear = calculateBearing(currentLoc.lat, currentLoc.lon, target.lat, target.lon);
          setDistance(distMeters);
          setBearing(bear);
        }
      }, [currentLoc, target]);

      // Metric System (m / km)
      const formatDistance = (meters) => {
        if (meters >= 1000) {
          return { value: (meters / 1000).toFixed(1), unit: 'km' };
        } else {
          return { value: meters.toFixed(1), unit: 'm' };
        }
      };

      const getDirectionText = (rotation) => {
        let normalized = ((rotation % 360) + 360) % 360;
        if (normalized > 180) normalized -= 360;

        if (Math.abs(normalized) <= 15) return { prefix: '', suffix: 'ahead' };
        if (Math.abs(normalized) >= 165) return { prefix: '', suffix: 'behind' };
        if (normalized > 15 && normalized < 165) return { prefix: 'to your', suffix: 'right' };
        if (normalized < -15 && normalized > -165) return { prefix: 'to your', suffix: 'left' };
        return { prefix: '', suffix: 'around' };
      };

      // --- RENDER SEARCH STATE ---
      // Replaced h-screen with h-full (which perfectly fills the 100dvh root body)
      if (appState === 'SEARCH') {
        return (
          <div className="flex flex-col h-full w-full max-w-md mx-auto bg-gray-50 text-gray-900 font-sans shadow-xl relative">
            <div className="p-6 bg-white border-b border-gray-200 shadow-sm z-10 flex-shrink-0">
              <h1 className="text-2xl font-bold mb-2">Find Location</h1>
              <p className="text-sm text-gray-500 mb-6">Search for a destination to begin precision tracking.</p>
              
              <form onSubmit={handleSearch} className="flex gap-2">
                <div className="relative flex-1">
                  <div className="absolute left-3 top-3 text-gray-400">
                    <SearchIcon size={20} />
                  </div>
                  <input 
                    type="text" 
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                    placeholder="Enter coordinates or address..." 
                    className="w-full pl-10 pr-4 py-3 bg-gray-100 rounded-xl outline-none focus:ring-2 focus:ring-[#1cd05a] transition-all"
                  />
                </div>
                <button 
                  type="submit" 
                  disabled={isSearching || !searchQuery}
                  className="bg-[#1cd05a] text-white p-3 rounded-xl hover:bg-green-600 disabled:opacity-50 transition-all flex items-center justify-center"
                >
                  {isSearching ? <CrosshairIcon size={20} className="animate-spin" /> : <SearchIcon size={20} />}
                </button>
              </form>
            </div>

            <div className="flex-1 overflow-y-auto p-4 space-y-3 pb-safe">
              {searchResults.map((item, idx) => {
                const isDistant = item.distFromUser !== undefined;
                const formattedDist = isDistant ? formatDistance(item.distFromUser) : null;
                
                return (
                  <div 
                    key={idx} 
                    onClick={() => selectTarget(item)}
                    className="flex items-start p-4 bg-white rounded-xl shadow-sm cursor-pointer hover:shadow-md transition-all active:scale-[0.98]"
                  >
                    <div className="bg-green-100 p-2 rounded-full mr-4 text-[#1cd05a] flex-shrink-0">
                      <MapPinIcon size={20} />
                    </div>
                    <div className="flex-1">
                      <h3 className="font-semibold text-gray-900 line-clamp-1">{item.display_name.split(',')[0]}</h3>
                      <p className="text-xs text-gray-500 line-clamp-2 mt-1">
                        {isDistant && <span className="font-medium text-[#1cd05a] mr-2">{formattedDist.value} {formattedDist.unit} away</span>}
                        {item.display_name}
                      </p>
                    </div>
                  </div>
                );
              })}
              
              {!isSearching && searchResults.length === 0 && (
                <div className="flex flex-col items-center justify-center h-full text-gray-400 opacity-60 mt-12">
                  <CompassIcon size={48} className="mb-4" />
                  <p>Search for a place to get started</p>
                </div>
              )}
            </div>
          </div>
        );
      }

      // --- RENDER TRACKING STATE ---
      const { value: distValue, unit: distUnit } = formatDistance(distance);
      const arrowRotation = bearing - heading;
      const directionText = getDirectionText(arrowRotation);
      
      const isClose = currentLoc && distance < 100;
      const bgClass = isClose ? 'bg-[#1cd05a]' : 'bg-zinc-900';

      let normRot = ((arrowRotation % 360) + 360) % 360;
      if (normRot > 180) normRot -= 360;

      // Replaced h-screen with h-full 
      return (
        <div className={`flex flex-col h-full w-full max-w-md mx-auto ${bgClass} text-white font-sans relative selection:bg-transparent touch-none transition-colors duration-1000 ease-in-out`}>
          
          {/* Top Header with Cancel 'X' Button */}
          <div className="pt-10 px-6 relative z-10 flex justify-between items-start flex-shrink-0">
            <div>
              <p className="text-white/60 text-[10px] font-bold tracking-widest uppercase mb-0.5">Finding</p>
              <h1 className="text-3xl font-bold tracking-tight line-clamp-1">{target?.name}</h1>
            </div>
            
            <button 
              onClick={stopTracking}
              className="w-12 h-12 bg-white/10 rounded-full flex items-center justify-center hover:bg-white/20 transition-colors active:scale-90 flex-shrink-0"
              aria-label="Cancel tracking"
            >
              <XIcon size={24} className="text-white" />
            </button>
          </div>

          {/* Main Center Area */}
          <div className="flex-1 flex items-center justify-center relative z-10 min-h-0">
            {!currentLoc ? (
              <div className="flex flex-col items-center animate-pulse">
                <CompassIcon size={64} className="text-white/50 mb-4 animate-spin" style={{ animationDuration: '3s' }} />
                <p className="text-lg font-medium">Acquiring GPS...</p>
                {geoError && (
                  <button onClick={() => startSensors(target)} className="text-sm text-red-200 mt-4 bg-red-900/40 p-3 rounded-lg max-w-xs text-center hover:bg-red-900/60 transition">
                    {geoError}
                  </button>
                )}
              </div>
            ) : (
              <div className="relative flex items-center justify-center w-full h-full p-4">
                
                {/* Master SVG containing Arrow, Dots, and Arc */}
                <svg viewBox="0 0 400 400" className="w-full max-w-[360px] max-h-full absolute inset-0 m-auto">
                  
                  {/* Faint circles */}
                  <circle cx="200" cy="200" r="180" stroke="rgba(255,255,255,0.08)" strokeWidth="2" fill="none" />
                  <circle cx="200" cy="200" r="3" fill="rgba(255,255,255,0.3)" />

                  {/* Dynamic Arc and Dots */}
                  {Math.abs(normRot) >= 15 && (() => {
                    const radius = 180;
                    const cx = 200;
                    const cy = 200;
                    
                    const startX = cx; 
                    const startY = cy - radius;
                    
                    const endRad = (normRot - 90) * Math.PI / 180;
                    const endX = cx + radius * Math.cos(endRad);
                    const endY = cy + radius * Math.sin(endRad);
                    
                    const sweepFlag = normRot > 0 ? 1 : 0;
                    const arcPath = `M ${startX} ${startY} A ${radius} ${radius} 0 0 ${sweepFlag} ${endX} ${endY}`;
                    
                    return (
                      <g>
                        <path d={arcPath} stroke="rgba(255,255,255,0.25)" strokeWidth="6" fill="none" strokeLinecap="round" />
                        <circle cx={startX} cy={startY} r="5" fill="rgba(255,255,255,0.25)" />
                        <circle cx={endX} cy={endY} r="7" fill="white" />
                      </g>
                    );
                  })()}

                  {/* Dynamic Rotated Arrow */}
                  <g 
                    style={{ 
                      transform: `rotate(${arrowRotation}deg)`, 
                      transformOrigin: '200px 200px',
                      transition: 'transform 0.15s cubic-bezier(0.2, 0.8, 0.2, 1)' 
                    }}
                  >
                    <path 
                      d="M 200,185 L 200,70 M 148,122 L 200,70 L 252,122" 
                      stroke="white" 
                      strokeWidth="30" 
                      strokeLinecap="round" 
                      strokeLinejoin="round" 
                      fill="none"
                    />
                  </g>
                </svg>

              </div>
            )}
          </div>

          {/* Bottom Area (Distance) - pb-10 added for extra safety margin above browser bottom bars */}
          <div className="pb-10 px-8 relative z-10 flex-shrink-0">
            {currentLoc && (
              <div className="mb-4">
                <div className="flex items-baseline gap-2">
                  <span className="text-[5rem] leading-none font-semibold tracking-tighter text-white">{distValue}</span>
                  <span className="text-4xl font-medium text-white/50">{distUnit}</span>
                </div>
                <p className="text-[32px] font-medium tracking-tight mt-1">
                  {directionText.prefix && <span className="text-white/50">{directionText.prefix} </span>}
                  <span className="text-white">{directionText.suffix}</span>
                </p>
              </div>
            )}
          </div>
          
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>