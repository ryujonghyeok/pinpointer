import React, { useState, useEffect, useCallback } from 'react';
import { X, Volume2, Search, MapPin, Compass, Crosshair, AlertCircle } from 'lucide-react';

// --- Math & Geo Utilities ---

// Converts degrees to radians
const toRad = (value) => (value * Math.PI) / 180;

// Converts radians to degrees
const toDeg = (value) => (value * 180) / Math.PI;

// Calculates distance between two coordinates in meters (Haversine formula)
const calculateDistance = (lat1, lon1, lat2, lon2) => {
  const R = 6371e3; // Earth's radius in meters
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
};

// Calculates the initial bearing from start point to end point
const calculateBearing = (lat1, lon1, lat2, lon2) => {
  const dLon = toRad(lon2 - lon1);
  const y = Math.sin(dLon) * Math.cos(toRad(lat2));
  const x =
    Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) -
    Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLon);
  const bearing = Math.atan2(y, x);
  return (toDeg(bearing) + 360) % 360;
};

// --- Main App Component ---

export default function App() {
  // App States
  const [appState, setAppState] = useState('SEARCH'); // 'SEARCH', 'TRACKING'
  
  // Search States
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);
  const [target, setTarget] = useState(null); // { lat, lon, name }

  // Sensor States
  const [currentLoc, setCurrentLoc] = useState(null); // { lat, lon, accuracy }
  const [heading, setHeading] = useState(0); // 0-360 degrees
  const [geoError, setGeoError] = useState(null);
  
  // Computed tracking data
  const [distance, setDistance] = useState(0);
  const [bearing, setBearing] = useState(0);

  // --- Location Search (Using free OpenStreetMap API for immediate prototyping) ---
  const handleSearch = async (e) => {
    e.preventDefault();
    if (!searchQuery.trim()) return;
    
    setIsSearching(true);
    try {
      // Free geocoding API. For production, swap with Google Maps Places API.
      const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchQuery)}&limit=5`);
      const data = await res.json();
      setSearchResults(data);
    } catch (err) {
      console.error("Search failed:", err.message || err);
      alert("Failed to search location. Please check your connection.");
    } finally {
      setIsSearching(false);
    }
  };

  const selectTarget = (item) => {
    const newTarget = {
      lat: parseFloat(item.lat),
      lon: parseFloat(item.lon),
      name: item.display_name.split(',')[0] // Get short name
    };
    setTarget(newTarget);
    setAppState('TRACKING');
    startSensors(newTarget);
  };

  // --- Sensor Management ---
  const handleOrientation = useCallback((event) => {
    let compassHeading = null;
    
    // iOS gives webkitCompassHeading
    if (event.webkitCompassHeading) {
      compassHeading = event.webkitCompassHeading;
    } 
    // Android/Standard fallback (alpha is rotation around z-axis)
    else if (event.alpha !== null) {
      // Depending on the browser/device, alpha might need adjustment.
      // 360 - alpha is a common approximation for compass heading.
      compassHeading = 360 - event.alpha;
    }
    
    if (compassHeading !== null) {
      setHeading(compassHeading);
    }
  }, []);

  const startSensors = async (currentTarget) => {
    setGeoError(null);

    // 1. Request GPS Geolocation
    if ('geolocation' in navigator) {
      navigator.geolocation.watchPosition(
        (position) => {
          setCurrentLoc({
            lat: position.coords.latitude,
            lon: position.coords.longitude,
            accuracy: position.coords.accuracy
          });
        },
        (error) => {
          console.error("Geolocation error:", error.message || error);
          setGeoError("GPS blocked/unavailable. Using simulated location.");
          // Often in iframes or canvas environments, GPS is blocked. Fall back to mock location to allow UI testing.
          if (currentTarget) {
            setCurrentLoc({
              lat: currentTarget.lat - 0.0003, // ~30 meters away offset
              lon: currentTarget.lon - 0.0003,
              accuracy: 5
            });
          }
        },
        { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
      );
    } else {
      setGeoError("Geolocation is not supported by your browser.");
    }

    // 2. Request Compass/Device Orientation
    // iOS 13+ requires explicit user permission for device orientation
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      try {
        const permission = await DeviceOrientationEvent.requestPermission();
        if (permission === 'granted') {
          window.addEventListener('deviceorientation', handleOrientation, true);
        } else {
          setGeoError("Compass permission denied.");
        }
      } catch (err) {
        console.error("Orientation permission error:", err.message || err);
      }
    } else {
      // Non iOS 13 devices
      window.addEventListener('deviceorientationabsolute', handleOrientation, true);
    }
  };

  const stopTracking = () => {
    setAppState('SEARCH');
    setTarget(null);
    setCurrentLoc(null);
    // Note: in a real app, you'd store the watchPosition ID and clear it here.
  };

  // --- Compute Tracking Math continuously ---
  useEffect(() => {
    if (currentLoc && target) {
      const distMeters = calculateDistance(currentLoc.lat, currentLoc.lon, target.lat, target.lon);
      const bear = calculateBearing(currentLoc.lat, currentLoc.lon, target.lat, target.lon);
      setDistance(distMeters);
      setBearing(bear);
    }
  }, [currentLoc, target]);

  // --- UI Formatters ---
  
  // Convert meters to feet, or miles if > 1000 ft
  const formatDistance = (meters) => {
    const feet = meters * 3.28084;
    if (feet < 1000) {
      return { value: Math.round(feet), unit: 'ft' };
    } else {
      const miles = feet / 5280;
      return { value: miles.toFixed(1), unit: 'mi' };
    }
  };

  // Determine direction word based on pointer rotation
  const getDirectionText = (rotation) => {
    // Normalize rotation to -180 to 180
    let normalized = ((rotation % 360) + 360) % 360;
    if (normalized > 180) normalized -= 360;

    if (Math.abs(normalized) <= 45) return 'ahead';
    if (Math.abs(normalized) >= 135) return 'behind';
    if (normalized > 45 && normalized < 135) return 'to your right';
    if (normalized < -45 && normalized > -135) return 'to your left';
    return 'around';
  };

  // --- RENDER ---

  if (appState === 'SEARCH') {
    return (
      <div className="flex flex-col h-screen max-w-md mx-auto bg-gray-50 text-gray-900 font-sans shadow-xl overflow-hidden relative">
        <div className="p-6 bg-white border-b border-gray-200">
          <h1 className="text-2xl font-bold mb-2">Find Location</h1>
          <p className="text-sm text-gray-500 mb-6">Search for a destination to begin precision tracking.</p>
          
          <form onSubmit={handleSearch} className="flex gap-2">
            <div className="relative flex-1">
              <Search className="absolute left-3 top-3 h-5 w-5 text-gray-400" />
              <input 
                type="text" 
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                placeholder="Enter address or coordinates..." 
                className="w-full pl-10 pr-4 py-3 bg-gray-100 rounded-xl outline-none focus:ring-2 focus:ring-[#1cd05a] transition-all"
              />
            </div>
            <button 
              type="submit" 
              disabled={isSearching || !searchQuery}
              className="bg-[#1cd05a] text-white p-3 rounded-xl hover:bg-green-600 disabled:opacity-50 transition-all"
            >
              {isSearching ? <Crosshair className="animate-spin" /> : <Search />}
            </button>
          </form>
        </div>

        <div className="flex-1 overflow-y-auto p-4 space-y-3">
          {searchResults.map((item, idx) => (
            <div 
              key={idx} 
              onClick={() => selectTarget(item)}
              className="flex items-start p-4 bg-white rounded-xl shadow-sm cursor-pointer hover:shadow-md transition-all active:scale-[0.98]"
            >
              <div className="bg-green-100 p-2 rounded-full mr-4 text-[#1cd05a]">
                <MapPin size={20} />
              </div>
              <div className="flex-1">
                <h3 className="font-semibold text-gray-900 line-clamp-1">{item.display_name.split(',')[0]}</h3>
                <p className="text-sm text-gray-500 line-clamp-2 mt-1">{item.display_name}</p>
              </div>
            </div>
          ))}
          
          {!isSearching && searchResults.length === 0 && (
            <div className="flex flex-col items-center justify-center h-48 text-gray-400">
              <Compass size={48} className="mb-4 opacity-20" />
              <p>Search for a place to get started</p>
            </div>
          )}
        </div>
      </div>
    );
  }

  // TRACKING STATE
  
  const { value: distValue, unit: distUnit } = formatDistance(distance);
  
  // The arrow needs to point towards the bearing, adjusted by our current compass heading.
  // If we are facing north (heading 0) and target is east (bearing 90), arrow points right (90deg).
  // If we turn right to face east (heading 90), arrow points straight ahead (0deg).
  const arrowRotation = bearing - heading;
  const directionText = getDirectionText(arrowRotation);

  return (
    <div className="flex flex-col h-screen max-w-md mx-auto bg-[#1cd05a] text-white font-sans overflow-hidden relative selection:bg-transparent touch-none">
      
      {/* Background pulsing circle effect */}
      <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-72 h-72 bg-white/10 rounded-full blur-2xl animate-pulse pointer-events-none" />
      <div className="absolute top-1/4 right-1/4 w-24 h-24 bg-white/20 rounded-full blur-xl animate-pulse pointer-events-none" style={{animationDelay: '1s'}} />

      {/* Top Header */}
      <div className="pt-16 px-8 relative z-10">
        <p className="text-white/80 text-xs font-bold tracking-widest uppercase mb-1">Finding</p>
        <h1 className="text-4xl font-bold tracking-tight shadow-sm line-clamp-1">{target?.name}</h1>
      </div>

      {/* Main Center Area (Arrow) */}
      <div className="flex-1 flex items-center justify-center relative z-10">
        {!currentLoc ? (
          <div className="flex flex-col items-center animate-pulse">
            <Compass className="w-16 h-16 text-white/50 mb-4 animate-spin-slow" style={{ animationDuration: '3s' }} />
            <p className="text-lg font-medium">Acquiring GPS...</p>
            {geoError && <p className="text-sm text-red-200 mt-2 bg-red-900/20 p-2 rounded max-w-xs text-center">{geoError}</p>}
          </div>
        ) : (
          <div className="relative flex items-center justify-center">
            {/* White Target Dot (Optional visual flair based on the image) */}
            <div 
              className="absolute w-12 h-12 bg-white/20 rounded-full flex items-center justify-center transition-all duration-700 ease-out"
              style={{ transform: `translate(0px, -120px)` }}
            >
               <div className="w-4 h-4 bg-white rounded-full shadow-lg" />
            </div>

            {/* Huge Directional Arrow */}
            <svg 
              viewBox="0 0 24 24" 
              fill="none" 
              stroke="white" 
              strokeWidth="3.5" 
              strokeLinecap="round" 
              strokeLinejoin="round" 
              className="w-56 h-56 drop-shadow-2xl will-change-transform"
              style={{ 
                transform: `rotate(${arrowRotation}deg)`, 
                transition: 'transform 0.15s cubic-bezier(0.2, 0.8, 0.2, 1)' 
              }}
            >
              <path d="M12 21V4" />
              <path d="M5 11l7-7 7 7" />
            </svg>
          </div>
        )}
      </div>

      {/* Bottom Area (Distance & Controls) */}
      <div className="pb-12 px-8 relative z-10">
        {currentLoc && (
          <div className="mb-8">
            <div className="flex items-baseline gap-1 drop-shadow-md">
              <span className="text-7xl font-semibold tracking-tighter">{distValue}</span>
              <span className="text-3xl font-medium text-white/80">{distUnit}</span>
            </div>
            <p className="text-4xl font-medium tracking-tight drop-shadow-md capitalize">
              {directionText}
            </p>
          </div>
        )}

        <div className="flex justify-between items-center mt-6">
          <button 
            onClick={stopTracking}
            className="w-14 h-14 bg-white/20 backdrop-blur-md rounded-full flex items-center justify-center hover:bg-white/30 transition-colors active:scale-90"
            aria-label="Stop tracking"
          >
            <X size={28} className="text-white" />
          </button>
          
          <button 
            className="w-14 h-14 bg-white/20 backdrop-blur-md rounded-full flex items-center justify-center hover:bg-white/30 transition-colors active:scale-90"
            aria-label="Play sound"
            onClick={() => alert('Playing sound on target... (Simulated)')}
          >
            <Volume2 size={24} className="text-white" />
          </button>
        </div>
      </div>
      
    </div>
  );
}